# Technical Details

## How Are the Plot and Questions Generated?

A distinguishing feature of this project lies in its innovative use of Large Language Models (LLMs) to generate plots and questions. This capability is made possible through OpenAI's "Structured Outputs" feature. 

According to OpenAI's documentation:

> Structured Outputs is a feature that ensures the model will always generate responses that adhere to your supplied JSON Schema, so you don't need to worry about the model omitting a required key or hallucinating an invalid enum value.

By leveraging this feature, the project ensures the LLM consistently generates valid JSON responses conforming to the specified schema.

For further reference, an example of using this feature can be found in [OpenAI's documentation](https://platform.openai.com/docs/guides/structured-outputs?lang=javascript).

The code implementation for this functionality within the project is available [here](https://github.com/nathanfhh/cybersecurity-scenario/blob/1db98892344b8097ef90b304f1f471c9e71b813b/src/components/PlotGenerator.vue). This implementation integrates schema definitions using the [Zod](https://zod.dev/) library to enforce the desired structure.

### Desired JSON Output
Below is an example of the JSON structure generated by the LLM:

```json
{
  "scenario": [
    {
      "type": "plot",
      "subtype": null,
      "content": "Description of the current scenario stage."
    },
    {
      "type": "questions",
      "subtype": "true-false",
      "question": "A cybersecurity question about the scenario.",
      "content": {
        "A": "True",
        "B": "False"
      },
      "answer": "A",
      "reason": "The reason why to choose A instead of B"
    },
    {
      "type": "questions",
      "subtype": "multiple-choice",
      "question": "A multiple-choice question based on the scenario.",
      "content": {
        "A": "Option A content",
        "B": "Option B content",
        "C": "Option C content",
        "D": "Option D content"
      },
      "answer": "A",
      "reason": "The reason why to choose A instead of other choices"
    },
    {
      "type": "questions",
      "subtype": "free-type",
      "question": "A free-response question that requires a critical answer.",
      "content": null,
      "answer": ""
    }
  ]
}
```

### Schema Definition with Zod
The following schema, defined using Zod, ensures the structure and validity of the generated JSON:

```javascript
import { z } from "zod";

const PlotSchema = z.object({
  type: z.literal("plot"),
  subtype: z.nullable(z.string()),
  content: z.string(),
});

const QuestionSchema = z.object({
  type: z.literal("questions"),
  subtype: z.enum(["true-false", "multiple-choice", "free-type"]),
  question: z.string(),
  content: z.union([
    z.record(z.string(), z.string()),  // For "true-false" and "multiple-choice" options
    z.null()  // For "free-type" questions
  ]),
  answer: z.union([z.string(), z.null()]), // Correct answer key or null for "free-type"
  reason: z.union([z.string(), z.null()])
});

const ScenarioSchema = z.object({
  scenario: z.array(z.union([PlotSchema, QuestionSchema]))
});
```

### Requesting JSON Generation from the LLM
The following code demonstrates how to request the LLM to generate JSON based on a prompt and the defined schema:

```javascript
import { zodResponseFormat } from "openai/helpers/zod";

const openai = new OpenAI();
const completion = await openai.beta.chat.completions.parse({
  model: "gpt-4o-2024-08-06",
  messages: [
    { role: "system", content: "SystemPromptHere" },
    { role: "user", content: "UserProvidedBasicScenario" },
  ],
  response_format: zodResponseFormat(ScenarioSchema, "scenario"),
});

const scenarioData = completion.choices[0].message.parsed;
```

This approach ensures that the generated plots and questions adhere to the intended structure, providing consistency and reliability in the output. By integrating Zod and OpenAI's "Structured Outputs," the project achieves a robust and maintainable solution for generating dynamic cybersecurity scenarios.

Here’s a polished and professional rewrite:

---

## How Are Images and Videos Selected?

The images used in the project are generated using DALL-E, while videos are created using SORA. To optimize performance and reduce processing time, all media files are pre-generated and stored in the project's assets folder.

### Media Selection Process
1. **Description and Embedding Generation**:  
   - Each image or video is manually described, and its description is used to calculate an embedding.
   - The embedding, along with the corresponding file path, is stored in a centralized [JSON file](https://github.com/nathanfhh/cybersecurity-scenario/blob/1db98892344b8097ef90b304f1f471c9e71b813b/src/assets/embed-data.json).

2. **Matching Media with Plot**:  
   - When a user navigates to a new tab containing a plot, the plot's embedding is calculated dynamically.
   - To identify the most suitable media file, the cosine similarity between the plot's embedding and the media description embeddings stored in the JSON file is computed. This matching logic is implemented in the [vector utility module](https://github.com/nathanfhh/cybersecurity-scenario/blob/1db98892344b8097ef90b304f1f471c9e71b813b/src/utility/vector.js).

3. **Enhancing Video Selection**:  
   - To prioritize video selection over images, a similarity score is multiplied by `1.03` if the media file is a `webm` video instead of a `webp` image. This ensures that videos are slightly more likely to be chosen.

4. **Ensuring Media Diversity**:  
   - To maximize diversity within a scenario, each image or video is displayed only once. This is achieved by tracking the media files already used in the current session and storing them in memory.


---

# 技術細節

## 劇情與問題是如何生成的？

本專案的一大特色在於其創新的應用大型語言模型（LLMs）來生成劇情和問題。這項能力得益於 OpenAI 的 **「結構化輸出」** 功能。

根據 OpenAI 的文件說明：

> 結構化輸出是一項功能，可確保模型始終生成符合您提供的 JSON 架構的回應，因此您不需要擔心模型遺漏必要的鍵值或產生無效的枚舉值。

透過這項功能，本專案能夠確保 LLM 生成的回應始終符合指定的 JSON 架構。

有關此功能的進一步參考範例，可以查看 [OpenAI 的文件](https://platform.openai.com/docs/guides/structured-outputs?lang=javascript)。

在本專案中實現該功能的程式碼可參考 [此處](https://github.com/nathanfhh/cybersecurity-scenario/blob/1db98892344b8097ef90b304f1f471c9e71b813b/src/components/PlotGenerator.vue)。該實現透過 [Zod](https://zod.dev/) 庫定義結構，以強化輸出的結構完整性。

### 預期的 JSON 輸出
以下是 LLM 所生成的 JSON 結構範例：

```json
{
  "scenario": [
    {
      "type": "plot",
      "subtype": null,
      "content": "描述當前場景階段的內容。"
    },
    {
      "type": "questions",
      "subtype": "true-false",
      "question": "與該場景相關的網路安全問題。",
      "content": {
        "A": "正確",
        "B": "錯誤"
      },
      "answer": "A",
      "reason": "選擇 A 而非 B 的理由"
    },
    {
      "type": "questions",
      "subtype": "multiple-choice",
      "question": "基於該場景的多選題。",
      "content": {
        "A": "選項 A 的內容",
        "B": "選項 B 的內容",
        "C": "選項 C 的內容",
        "D": "選項 D 的內容"
      },
      "answer": "A",
      "reason": "選擇 A 而非其他選項的理由"
    },
    {
      "type": "questions",
      "subtype": "free-type",
      "question": "需要批判性回答的自由題。",
      "content": null,
      "answer": ""
    }
  ]
}
```

### 使用 Zod 定義架構
以下是使用 Zod 定義 JSON 架構的程式碼範例：

```javascript
import { z } from "zod";

const PlotSchema = z.object({
  type: z.literal("plot"),
  subtype: z.nullable(z.string()),
  content: z.string(),
});

const QuestionSchema = z.object({
  type: z.literal("questions"),
  subtype: z.enum(["true-false", "multiple-choice", "free-type"]),
  question: z.string(),
  content: z.union([
    z.record(z.string(), z.string()),  // 適用於「是非題」和「多選題」的選項格式
    z.null()  // 適用於「自由題」，內容為 null
  ]),
  answer: z.union([z.string(), z.null()]), // 正確答案的鍵值或 null（適用於自由題）
  reason: z.union([z.string(), z.null()])
});

const ScenarioSchema = z.object({
  scenario: z.array(z.union([PlotSchema, QuestionSchema]))
});
```

### 向 LLM 請求生成 JSON
以下程式碼展示如何向 LLM 提出請求，生成符合架構的 JSON：

```javascript
import { zodResponseFormat } from "openai/helpers/zod";

const openai = new OpenAI();
const completion = await openai.beta.chat.completions.parse({
  model: "gpt-4o-2024-08-06",
  messages: [
    { role: "system", content: "SystemPromptHere" },
    { role: "user", content: "UserProvidedBasicScenario" },
  ],
  response_format: zodResponseFormat(ScenarioSchema, "scenario"),
});

const scenarioData = completion.choices[0].message.parsed;
```

此方法確保生成的劇情與問題遵循預期的結構，並提供一致性與可靠性。透過結合 Zod 與 OpenAI 的「結構化輸出」功能，本專案實現了一個穩健且易於維護的動態網路安全場景生成解決方案。


## 圖片和影片如何選擇？

專案中使用的圖片是透過 **DALL-E** 生成的，而影片則由 **SORA** 製作。為了優化效能並減少處理時間，所有媒體檔案均提前生成並存放於專案的資產資料夾中。

### 媒體選擇流程

1. **描述與嵌入計算**：  
   - 每個圖片或影片都會手動撰寫描述，並根據該描述計算其嵌入向量（embedding）。  
   - 計算完成後，嵌入向量與對應的檔案路徑會儲存在一個集中的 [JSON 檔案](https://github.com/nathanfhh/cybersecurity-scenario/blob/1db98892344b8097ef90b304f1f471c9e71b813b/src/assets/embed-data.json) 中。

2. **將媒體與劇情匹配**：  
   - 當使用者切換到包含劇情的分頁時，系統會動態計算該劇情的嵌入向量。  
   - 接著，透過計算劇情嵌入與 JSON 檔案中媒體描述嵌入的 **餘弦相似度**，找出最符合的媒體檔案。該匹配邏輯的實作可參考 [向量工具模組](https://github.com/nathanfhh/cybersecurity-scenario/blob/1db98892344b8097ef90b304f1f471c9e71b813b/src/utility/vector.js)。

3. **提升影片的優先選擇機率**：  
   - 若媒體檔案為 `webm` 影片而非 `webp` 圖片，系統會將相似度分數乘以 `1.03`，以提高影片被選擇的機率。

4. **確保媒體多樣性**：  
   - 為了在同一場景中最大化媒體多樣性，每個圖片或影片只會出現一次。這透過記錄當前場景中已使用的媒體檔案並將其儲存在記憶體中來實現。



